#!/usr/bin/env node
var j=Object.defineProperty;var c=(t,e)=>j(t,"name",{value:e,configurable:!0});import a from"node:path";import{cli as P}from"cleye";import l from"node:fs/promises";import{parseTsconfig as F}from"get-tsconfig";import m from"split2";import{spawn as x}from"node:child_process";import{findUp as v}from"find-up-simple";import{lookpath as u}from"lookpath";var d="tc-passing",$="Only type check previously passing files";const S=c(async t=>{const e=t.endsWith(".json")?t:a.join(t,"tsconfig.json");if(!await l.access(e).then(()=>!0,()=>!1))throw new Error(`Could not find tsconfig.json in ${t}`);if(!F(e))throw new Error("No tsconfig.json found in CWD. Make sure you run this in a directory with a tsconfig.json file");const o=a.dirname(e);return{tsconfigPath:e,projectPath:o}},"getTsconfig"),C=c(t=>{const e=new Promise((s,i)=>{t.on("close",s),t.on("error",i)});return Object.assign(t,{promise:e})},"childPromise"),y=c(async t=>{const e={env:{...process.env}},s=await v("node_modules/.bin",{type:"directory"});s&&(e.env.PATH=[process.env.PATH,s].join(":"));const i=await u("vue-tsc",e)??await u("tsc",e);if(!i)throw new Error("Could not find command `tsc`. Make sure `typescript` installed in the project");return C(x(i,["--noEmit",...t],e))},"spawnTsc"),b=/^(.+)\(\d+,\d+\):/,B=c(async t=>{const e=new Set,s=new Set,i=t.projectPath+a.sep;console.log("update-baseline.ts",{tsconfig:t});const o=await y(["--listFiles","-p",t.tsconfigPath]);o.stdout.pipe(m()).on("data",r=>{if(console.log({data:r}),r.startsWith(i)){const f=r.slice(i.length);f.startsWith(`node_modules${a.sep}`)||s.add(f);return}const n=r.match(b);n&&e.add(n[1])}),console.log(o),await o.promise;const p=s.size;for(const r of e)s.delete(r);return{passingPercent:(s.size/p).toLocaleString("en-US",{style:"percent",maximumFractionDigits:2}),files:Array.from(s).sort()}},"getPassingFiles$1"),E=c(async(t,e)=>{const{passingPercent:s,files:i}=await B(t);await l.writeFile(e,`# Files passing type check (${s}) (Generated by ${d})
${i.join(`
`)}`),console.log(`Generated baseline file: ${a.relative(process.cwd(),e)}`)},"updateBaseline"),T=c(async t=>{if(!await l.access(t).then(()=>!0,()=>!1))throw new Error(`Could not find baseline file at ${t}
Run with --update to generate a baseline file`);return(await l.readFile(t,"utf8")).split(`
`).slice(1)},"getPassingFiles"),h="\x1B[96m",W=c(async(t,e)=>{const s=await T(e),i=a.join(t.projectPath,`.tsconfig.${Date.now()}.json`);await l.writeFile(i,JSON.stringify({extends:t.tsconfigPath,files:s,include:[]}));const o=c(async()=>{await l.rm(i).catch(()=>{}),process.off("exit",o)},"cleanup");process.once("exit",o);const p=a.relative(process.cwd(),t.projectPath);try{const r=await y(["--pretty","-p",i]);r.stdout.pipe(m(`

${h}`)).on("data",n=>{n=n.toString(),n.startsWith(h)&&(n=n.slice(h.length));const f=n.indexOf(`

Found `);f>-1&&(n=n.slice(0,f+2));const w=n.indexOf("\x1B[0m:");if(w>-1){let g=n.slice(0,w);p&&g.startsWith(`${p}/`)&&(g=g.slice(p.length+1)),s.includes(g)&&(process.stdout.write(`${h+n}
`),process.exitCode=1)}}),await r.promise}finally{await o()}},"typeCheckBaseline");(async()=>{const t=P({name:d,description:$,flags:{update:{type:Boolean,alias:"u",description:"Update the baseline list of passing files"},file:{type:String,description:"Path to the baseline file containing files passing type check",default:`.${d}`},project:{type:String,alias:"p",description:"Compile the project given the path to its configuration file, or to a folder with a 'tsconfig.json'."}}}),e=await S(t.flags.project??process.cwd()),s=a.join(e.projectPath,t.flags.file);if(t.flags.update){await E(e,s);return}await W(e,s)})();
