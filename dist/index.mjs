#!/usr/bin/env node
var P=Object.defineProperty;var r=(t,e)=>P(t,"name",{value:e,configurable:!0});import c from"node:path";import{cli as F}from"cleye";import p from"node:fs/promises";import{parseTsconfig as v}from"get-tsconfig";import u from"split2";import{spawn as x}from"node:child_process";import{findUp as $}from"find-up-simple";import{lookpath as y}from"lookpath";import S from"node:fs";import C from"exit-hook";var d="tc-passing",E="Only type check previously passing files";const b=r(async t=>{const e=t.endsWith(".json")?t:c.join(t,"tsconfig.json");if(!await p.access(e).then(()=>!0,()=>!1))throw new Error(`Could not find tsconfig.json in ${t}`);if(!v(e))throw new Error("No tsconfig.json found in CWD. Make sure you run this in a directory with a tsconfig.json file");const a=c.dirname(e);return{tsconfigPath:e,projectPath:a}},"getTsconfig"),k=r(t=>{const e=new Promise((s,i)=>{t.on("close",s),t.on("error",i)});return Object.assign(t,{promise:e})},"childPromise"),j=r(async t=>{const e={env:{...process.env}},s=await $("node_modules/.bin",{type:"directory"});s&&(e.env.PATH=[process.env.PATH,s].join(":"));const i=await y("vue-tsc",e)??await y("tsc",e);if(!i)throw new Error("Could not find command `tsc`. Make sure `typescript` installed in the project");return k(x(i,["--noEmit",...t],e))},"spawnTsc"),B=/^(.+)\(\d+,\d+\):/,T=r(async t=>{const e=new Set,s=new Set,i=t.projectPath+c.sep,a=await j(["--listFiles","-p",t.tsconfigPath]);a.stdout.pipe(u()).on("data",o=>{if(o.startsWith(i)){const n=o.slice(i.length);n.startsWith(`node_modules${c.sep}`)||s.add(n);return}const l=o.match(B);l&&e.add(l[1])}),await a.promise;const m=s.size;for(const o of e)s.delete(o);return{passingPercent:(s.size/m).toLocaleString("en-US",{style:"percent",maximumFractionDigits:2}),files:Array.from(s).sort()}},"getPassingFiles$1"),W=r(async(t,e)=>{const{passingPercent:s,files:i}=await T(t);await p.writeFile(e,`# Files passing type check (${s}) (Generated by ${d})
${i.join(`
`)}`),console.log(`Generated baseline file: ${c.relative(process.cwd(),e)}`)},"updateBaseline"),O=r(async t=>{if(!await p.access(t).then(()=>!0,()=>!1))throw new Error(`Could not find baseline file at ${t}
Run with --update to generate a baseline file`);return(await p.readFile(t,"utf8")).split(`
`).slice(1)},"getPassingFiles"),g="\x1B[96m",A=r(async(t,e)=>{const s=await O(e),i=c.join(t.projectPath,`.tsconfig.${Date.now()}.json`);await p.writeFile(i,JSON.stringify({extends:t.tsconfigPath,files:s,include:[]}));const a=r(()=>{S.rmSync(i),m()},"cleanup"),m=C(a),o=c.relative(process.cwd(),t.projectPath);try{const l=await j(["--pretty","-p",i]);l.stdout.pipe(u(`

${g}`)).on("data",n=>{n=n.toString(),n.startsWith(g)&&(n=n.slice(g.length));const h=n.indexOf(`

Found `);h>-1&&(n=n.slice(0,h+2));const w=n.indexOf("\x1B[0m:");if(w===-1)return;let f=n.slice(0,w);o&&f.startsWith(`${o}/`)&&(f=f.slice(o.length+1)),s.includes(f)&&(process.stdout.write(`${g+n}
`),process.exitCode=1)}),await l.promise}finally{a()}},"typeCheckBaseline");(async()=>{const t=F({name:d,description:E,flags:{update:{type:Boolean,alias:"u",description:"Update the baseline list of passing files"},file:{type:String,description:"Path to the baseline file containing files passing type check",default:`.${d}`},project:{type:String,alias:"p",description:"Compile the project given the path to its configuration file, or to a folder with a 'tsconfig.json'."}}}),e=await b(t.flags.project??process.cwd()),s=c.join(e.projectPath,t.flags.file);if(t.flags.update){await W(e,s);return}await A(e,s)})();
